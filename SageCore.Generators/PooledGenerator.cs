// -----------------------------------------------------------------------
// <copyright file="PooledGenerator.cs" company="SageCore Contributors">
// 2025 Copyright (c) SageCore Contributors. All rights reserved.
// Licensed under the MIT license.
// See LICENSE.md for more information.
// </copyright>
// -----------------------------------------------------------------------

using System.Collections.Immutable;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace SageCore.Generators;

/// <summary>Generates source code for classes marked with the PooledAttribute that must be partial and adds object pool functionality for the target class.</summary>
/// <remarks>This generator scans all classes within the compilation to identify those annotated with SageCore.Attributes.PooledAttribute, ensuring they are partial, and then emits the necessary source code to enable object pooling functionality.</remarks>
/// <example>This generator requires the target classes to:<list type="bullet"><item>Be marked with SageCore.Attributes.PooledAttribute.</item><item>Be declared as partial.</item></list>The generator will skip invalid or duplicate entries during compilation.</example>
/// <exception cref="InvalidOperationException">Throws if a class marked with the required attribute does not meet the necessary constraints.</exception>
/// <seealso cref="IIncrementalGenerator"/>
[Generator]
public sealed class PooledGenerator : IIncrementalGenerator
{
    /// <summary>Initializes the source generator by registering the required syntax and compile-time processing logic.</summary>
    /// <param name="context">The contextual information provided for initializing incremental generators, allowing subscription to syntax and compilation events.</param>
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        IncrementalValuesProvider<INamedTypeSymbol?> candidates = context
            .SyntaxProvider.CreateSyntaxProvider(
                static (node, _) => node is ClassDeclarationSyntax { AttributeLists.Count: > 0 },
                static (ctx, _) => GetPooledClassSymbol(ctx)
            )
            .Where(static s => s is not null);

        IncrementalValueProvider<(Compilation Left, ImmutableArray<INamedTypeSymbol?> Right)> compilationAndClasses =
            context.CompilationProvider.Combine(candidates.Collect());
        context.RegisterSourceOutput(
            compilationAndClasses,
            static (spc, pair) =>
            {
                (_, ImmutableArray<INamedTypeSymbol?> classes) = pair;
                var seen = new HashSet<string>();

                foreach (INamedTypeSymbol? cls in Enumerable.OfType<INamedTypeSymbol>(classes))
                {
                    ProcessClass(spc, cls, seen);
                }
            }
        );
    }

    private static string GenerateObjectPoolPartial(string? ns, string typeName, string accessModifier)
    {
        var nSpaceOpen = ns is null ? string.Empty : $"namespace {ns}";
        return $$"""
            // <auto-generated />
            #nullable enable
            using System.Diagnostics.CodeAnalysis;
            using Microsoft.Extensions.ObjectPool;
            using SageCore.Attributes;
            using SageCore.Abstractions;

            {{nSpaceOpen}};

            {{accessModifier}} partial class {{typeName}}
            {
                private static readonly ObjectPool<{{typeName}}> Pool = new DefaultObjectPool<{{typeName}}>(new __{{typeName}}Policy());

                /// <summary>Gets an instance of the <see cref="{{typeName}}"/> class from the pool.</summary>
                /// <returns>An instance of the <see cref="{{typeName}}"/> class.</returns>
                /// <remarks>The instance is returned to the pool when it is disposed.</remarks>
                public static {{typeName}} Rent()
                {
                    var obj = Pool.Get();
                    return obj;
                }

                /// <summary>Returns an instance of the <see cref="{{typeName}}"/> class to the pool.</summary>
                /// <param name="obj">The instance to return to the pool.</param>
                /// <remarks>The instance is returned to the pool when it is disposed.</remarks>
                public static void Return([NotNull] {{typeName}} obj) => Pool.Return(obj);
                
                /// <summary>Gets an instance of the <see cref="{{typeName}}"/> class from the pool and returns it to the caller.</summary>
                /// <param name="instance">When this method returns, contains an instance of the <see cref="{{typeName}}"/> class.</param>
                /// <returns>A <see cref="SafeLease"/> that can be used to return the instance to the pool when it is no longer needed.</returns>
                /// <remarks>The instance is returned to the pool when the <see cref="SafeLease"/> is disposed.</remarks>
                public static SafeLease Lease(out {{typeName}} instance)
                {
                    var obj = Rent();
                    instance = obj;
                    return new SafeLease(obj);
                }
                
                /// <summary>Returns an instance of the <see cref="{{typeName}}"/> class to the pool.</summary>
                /// <remarks>The instance is returned to the pool when the <see cref="SafeLease"/> is disposed.</remarks>
                public struct SafeLease : IDisposable
                {
                    private {{typeName}}? _instance;

                    /// <summary>Gets the instance of the <see cref="{{typeName}}"/> class.</summary>
                    /// <exception cref="ObjectDisposedException">Thrown if the instance has been returned to the pool.</exception>
                    public {{typeName}} Instance => _instance ?? throw new ObjectDisposedException(typeof({{typeName}}).Name);

                    /// <summary>Returns the instance of the <see cref="{{typeName}}"/> class to the pool.</summary>
                    /// <remarks>This method is idempotent and can be called multiple times.</remarks>
                    public void Dispose()
                    {
                        var inst = Interlocked.Exchange(ref _instance, null);
                        if (inst is not null)
                        {
                            Return(inst);
                        }
                    }

                    internal SafeLease([NotNull] {{typeName}} instance) => _instance = instance;
                }

                private sealed class __{{typeName}}Policy : PooledObjectPolicy<{{typeName}}>
                {
                    public override {{typeName}} Create() => new {{typeName}}();

                    public override bool Return([NotNull] {{typeName}} obj)
                    {
                        if (obj is IPooledResettable r)
                        {
                            r.Reset();
                        }

                        return true; // keep in pool
                    }
                }
            }
            #nullable restore
            """;
    }

    private static bool HasPooledAttribute(INamedTypeSymbol symbol) =>
        symbol.GetAttributes().Any(a => a.AttributeClass?.ToDisplayString() == "SageCore.Attributes.PooledAttribute");

    private static INamedTypeSymbol? GetPooledClassSymbolThirdStep(INamedTypeSymbol symbol) =>
        HasPooledAttribute(symbol) ? symbol : null;

    private static INamedTypeSymbol? GetPooledClassSymbolSecondStep(
        GeneratorSyntaxContext ctx,
        ClassDeclarationSyntax cds
    ) =>
        ModelExtensions.GetDeclaredSymbol(ctx.SemanticModel, cds) is not INamedTypeSymbol symbol
            ? null
            : GetPooledClassSymbolThirdStep(symbol);

    private static INamedTypeSymbol? GetPooledClassSymbol(GeneratorSyntaxContext ctx) =>
        ctx.Node is not ClassDeclarationSyntax cds ? null : GetPooledClassSymbolSecondStep(ctx, cds);

    private static bool IsPartial(INamedTypeSymbol cls) =>
        cls.DeclaringSyntaxReferences.Any(r =>
            r.GetSyntax() is ClassDeclarationSyntax cds && cds.Modifiers.Any(m => m.IsKind(SyntaxKind.PartialKeyword))
        );

    private static void ReportNotPartial(SourceProductionContext spc, INamedTypeSymbol cls)
    {
        var descriptor = new DiagnosticDescriptor(
            id: "POOLED",
            title: "Class must be partial",
            messageFormat: "Class '{0}' must be declared partial to use [Pooled]",
            category: "Pooled",
            DiagnosticSeverity.Error,
            isEnabledByDefault: true
        );

        spc.ReportDiagnostic(Diagnostic.Create(descriptor, Location.None, cls.ToDisplayString()));
    }

    private static string? GetNamespace(INamedTypeSymbol cls) =>
        cls.ContainingNamespace.IsGlobalNamespace ? null : cls.ContainingNamespace.ToDisplayString();

    private static string BuildHint(string? ns, string typeName) =>
        $"{(ns is null ? string.Empty : $"{ns}.")}{typeName}.Pooled.g.cs";

    private static string GetAccessModifier(Accessibility accessibility) =>
        accessibility switch
        {
            Accessibility.Public => "public",
            Accessibility.Internal => "internal",
            Accessibility.Protected => "protected",
            Accessibility.Private => "private",
            Accessibility.ProtectedOrInternal => "protected internal",
            Accessibility.ProtectedAndInternal => "private protected",
            Accessibility.NotApplicable => string.Empty,
            _ => "internal",
        };

    private static void ProcessClass(SourceProductionContext spc, INamedTypeSymbol cls, HashSet<string> seen)
    {
        if (!IsPartial(cls))
        {
            ReportNotPartial(spc, cls);
            return;
        }

        var ns = GetNamespace(cls);
        var typeName = cls.Name;
        var fullHint = BuildHint(ns, typeName);

        if (!seen.Add(fullHint))
        {
            return;
        }

        var accessModifier = GetAccessModifier(cls.DeclaredAccessibility);
        var code = GenerateObjectPoolPartial(ns, typeName, accessModifier);
        spc.AddSource(fullHint, code);
    }
}
